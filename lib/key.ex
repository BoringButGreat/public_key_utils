import Record
import PublicKeyUtils.OID

defmodule PublicKeyUtils.Key do
  defstruct algorithm: nil, key: nil, private: false
  @type t :: %__MODULE__{algorithm: atom(), key: term(), private: boolean()}
  @moduledoc """
  Utilities to interact with erlang crypto key formats.

  There are also several record macros included from "public_key/include/public_key.hrl".
  These can be used to extract out the internal data structures of the keys, such
  as the RSA primes, or the name of the EC curve.
  """

  hrl = [from_lib: "public_key/include/public_key.hrl"]
  defrecord :subject_public_key_info, :SubjectPublicKeyInfo, extract(:SubjectPublicKeyInfo, hrl)
  defrecord :rsa_private_key, :RSAPrivateKey, extract(:RSAPrivateKey, hrl)
  defrecord :rsa_public_key, :RSAPublicKey, extract(:RSAPublicKey, hrl)
  defrecord :dsa_private_key, :DSAPrivateKey, extract(:DSAPrivateKey, hrl)
  defrecord :dss_parms, :"Dss-Parms", extract(:"Dss-Parms", hrl)
  defrecord :ec_private_key, :ECPrivateKey, extract(:ECPrivateKey, hrl)
  defrecord :ec_point, :ECPoint, extract(:ECPoint, hrl)
  defrecord :ec_parameters, :ECParameters, extract(:ECParameters, hrl)
  defrecord :private_key_info, :PrivateKeyInfo, extract(:PrivateKeyInfo, hrl)

  @doc """
  Tries really, really hard to get a key from whatever you pass in.

  Does not work with encrypted keys (protected by password).

  PEM/DER decoding takes about a millisecond, so you may want to store the value
  in an ets table or :erlang.term_to_binary and put it in a database/cache.

  It's expected that the key was probably generated by one of:
  - `openssl` (genrsa, gendsa, ecparam -genkey, etc.) maybe with a -nodes (don't encrypt)
  - `ssh-keygen` (-t rsa, -t dsa, -t ecdsa, etc.) (with empty passphrase)

  Parameters
    - `key`
      - PEM formatted binary (`-----BEGIN xxx PRIVATE KEY-----`)
      - DER formatted binary
      - SSH formatted binary (`ssh-xxx xxxxx`)
      - Erlang `:public_key` format
        - RSA `rsa_private_key()` | `rsa_public_key()`
        - DSA `dsa_private_key()` | `{int, dss_parms()}`
        - Elliptic Curve `ec_private_key()` | `{ec_point(), ec_parameters()}`
        - PEM entry
          - `{PrivateKeyInfo, binary, :not_encrypted}`
          - `{algorithm, binary, :not_encrypted}`
        - DER encoded `private_key_info()`

  Returns
    `{:error, :invalid_key}` if it's encrypted or not a key
    `{:ok, key}` success! key could be any of the Erlang :public_key formats
  """
  def load(key) do
    with {:ok, key} <- _load_key(key) do
      case key do
        rsa_private_key() ->
          {:ok, %__MODULE__{
            algorithm: :rsa,
            private: true,
            key: key
          }}
        rsa_public_key() ->
          {:ok, %__MODULE__{
            algorithm: :rsa,
            key: key
          }}
        dsa_private_key() ->
          {:ok, %__MODULE__{
            algorithm: :dsa,
            private: true,
            key: key
          }}
        {int, dss_parms()} when is_integer(int) ->
          {:ok, %__MODULE__{
            algorithm: :dsa,
            key: key
          }}
        ec_private_key() ->
          {:ok, %__MODULE__{
            algorithm: :ec,
            key: key,
            private: true
          }}
        {ec_point(), ec_parameters()} ->
          {:ok, %__MODULE__{
            algorithm: :ec,
            key: key
          }}
        {ec_point() = point, {:namedCurve, curve}} ->
          case to_oid(curve) do
            :unknown ->
              {:ok, %__MODULE__{
                algorithm: :ec,
                key: key
              }}
            curve ->
              {:ok, %__MODULE__{
                algorithm: :ec,
                key: {point, {:namedCurve, curve}}
              }}
          end
      end
    end
  end
  def _load_key({:error, _} = error), do: error
  def _load_key(rsa_private_key() = key), do: {:ok, key}
  def _load_key(rsa_public_key() = key), do: {:ok, key}
  def _load_key(dsa_private_key() = key), do: {:ok, key}
  def _load_key({int, dss_parms()} = key) when is_integer(int), do: {:ok, key}
  def _load_key(ec_private_key(parameters: {:ecParameters, params}) = key), do: {:ok, ec_private_key(key, parameters: params)}
  def _load_key(ec_private_key() = key), do: {:ok, key}
  def _load_key({ec_point(), ec_parameters()} = key), do: {:ok, key}
  def _load_key({ec_point(), {:namedCurve, _}} = key), do: {:ok, key}
  def _load_key({ec_point() = point, {:ecParameters, ec_parameters() = params}}), do: {:ok, {point, params}}
  def _load_key({ec_point() = point, {:ecParameters, {:namedCurve, _} = params}}), do: {:ok, {point, params}}
  def _load_key({:PrivateKeyInfo, _, :not_encrypted} = key) do
    :public_key.pem_entry_decode(key)
    |> _load_key
  end
  def _load_key({:SubjectPublicKeyInfo, _, :not_encrypted} = key) do
    :public_key.pem_entry_decode(key)
    |> _load_key
  end
  def _load_key(subject_public_key_info(algorithm: {:AlgorithmIdentifier, oid, parms}, subjectPublicKey: key)) do
    case from_oid(oid) do
      :rsaEncryption ->
        :public_key.der_decode(:RSAPublicKey, key)
      :"id-dsa" ->
        {
          :public_key.der_decode(:DSAPublicKey, key),
          :public_key.der_decode(:"Dss-Parms", parms)
        }
      :"id-ecPublicKey" ->
        parms =
          case parms do
            <<6>> <> _ = oid -> # OID
              {{6, oid}, _} = :asn1rt_nif.decode_ber_tlv(oid)
              {:namedCurve,
                decode_binary_oid(oid)
                |> from_oid
              }
            _ ->
              case :public_key.der_decode(:ECParameters, parms) do
                {:ecParameters, ec_parameters() = parms} -> parms
                ec_parameters() = parms ->
                  parms
              end
          end
        {{:ECPoint, key}, parms}
    end
    |> _load_key
  end
  def _load_key({key_type, der, :not_encrypted} = entry) when is_atom(key_type) do
    case :public_key.pem_entry_decode(entry) |> _load_key do
      {:ok, _} = key -> key
      _ -> :public_key.der_decode(key_type, der) |> _load_key
    end
  end
  def _load_key(private_key_info(privateKeyAlgorithm: key_type, privateKey: bin)) do
    :public_key.der_decode(key_type, bin)
    |> _load_key
  end
  def _load_key(pem_or_der_or_ssh) when is_binary(pem_or_der_or_ssh) do
    case :public_key.pem_decode(pem_or_der_or_ssh) do
      [] ->
        try do
          [{key, _}] = :public_key.ssh_decode(pem_or_der_or_ssh, :public_key)
          key
        rescue
          _ ->
            [:RSAPrivateKey, :RSAPublicKey, :DSAPrivateKey, :DSAPublicKey, :ECPrivateKey, :SubjectPublicKeyInfo]
            |> Enum.find_value({:error, :invalid_key}, fn(key_type) ->
              try do
                :public_key.der_decode(key_type, pem_or_der_or_ssh)
              rescue
                _ -> false
              end
            end)
        end
      keys -> keys
    end
    |> _load_key
  end
  def _load_key([head | rest]) do
    case _load_key(head) do
      {:error, _} -> _load_key(rest)
      good -> good
    end
  end
  def _load_key(_), do: {:error, :invalid_key}

  @doc """
  Encrypts a binary with an RSA key.

  Currently no other public key crypto supports encryption.
  """
  def encrypt(data, key)
  def encrypt(_data, %__MODULE__{algorithm: :dsa}), do: {:error, :dsa_can_not_encrypt}
  def encrypt(_data, %__MODULE__{algorithm: :ec}), do: {:error, :ec_can_not_encrypt}
  def encrypt(data, %__MODULE__{key: key, private: true}) do
    :public_key.encrypt_private(data, key)
  end
  def encrypt(data, %__MODULE__{key: key, private: false}) do
    :public_key.encrypt_public(data, key)
  end

  @doc """
  Decrypts a binary with an RSA key.

  Currently no other public key crypto supports decryption.
  """
  def decrypt(data, key)
  def decrypt(_data, %__MODULE__{algorithm: :dsa}), do: {:error, :dsa_can_not_decrypt}
  def decrypt(_data, %__MODULE__{algorithm: :ec}), do: {:error, :ec_can_not_decrypt}
  def decrypt(data, %__MODULE__{key: key, private: true}) do
    try do
      {:ok, :public_key.decrypt_private(data, key)}
    rescue
      e in ErlangError -> {:error, e.original}
    end
  end
  def decrypt(data, %__MODULE__{key: key, private: false}) do
    try do
      {:ok, :public_key.decrypt_public(data, key)}
    rescue
      e in ErlangError -> {:error, e.original}
    end
  end

  @doc """
  Signs a binary with key and hash (default :sha).

  Hash can be :sha256, :sha512, or other supported hashes, or :none if caller hashes the data.

  DSA is only supported with :sha
  """
  def sign(data, key, hash \\ :sha)
  def sign(_, %__MODULE__{algorithm: :dsa}, hash) when hash != :sha, do: {:error, :invalid_hash_for_dsa}
  def sign(data, %__MODULE__{private: true, key: key}, hash) do
    :public_key.sign(data, hash, key)
  end

  @doc """
  Verifies a signature of a binary with key and hash (default :sha).

  Hash can be :sha256, :sha512, or other supported hashes, or :none if caller hashes the data.

  DSA is only supported with :sha

  Returns true/false
  """
  def verify(data, signature, key, hash \\ :sha)
  def verify(_, _, %__MODULE__{algorithm: :dsa}, hash) when hash != :sha, do: {:error, :invalid_hash_for_dsa}
  def verify(data, signature, %__MODULE__{private: false, key: key}, hash) do
    :public_key.verify(data, hash, signature, key)
  end

  def verify(data, signature, key, hash) do
    verify(data, signature, public(key), hash)
  end

  @doc """
  Convert a private key to a public key. Useful when you want to encrypt with the public key side of
  and existing private key.
  """
  def public(%__MODULE__{private: true, algorithm: :ec, key: ec_private_key(publicKey: public, parameters: params)}) do
    %__MODULE__{key: {{:ECPoint, public}, params}, algorithm: :ec, private: false}
  end
  def public(%__MODULE__{private: true, algorithm: :rsa, key: rsa_private_key(modulus: modulus, publicExponent: public_exponent)}) do
    %__MODULE__{key: rsa_public_key(modulus: modulus, publicExponent: public_exponent), algorithm: :rsa, private: false}
  end
  def public(%__MODULE__{private: true, algorithm: :dsa, key: dsa_private_key(y: y, p: p, q: q, g: g)}) do
    %__MODULE__{key: {y, dss_parms(p: p, q: q, g: g)}, algorithm: :dsa, private: false}
  end
end
